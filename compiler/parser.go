package compiler

import (
	"encoding/xml"
	"fmt"
	"io"
	"regexp"
	"strings"
)

type Node struct {
	XMLName  xml.Name
	Attrs    []xml.Attr `xml:",any,attr"`
	Content  string     `xml:",chardata"`
	Children []Node     `xml:",any"`
}

var eventRegex = regexp.MustCompile(`\(([\w-]+)\)=`)
var gIfRegex = regexp.MustCompile(`\*gIf=`)

func GenerateFullFile(n Node, packageName string) string {
	body := generateNodeCode(n, "root", "", 0)

	signalImport := "go-frontend-framework/signal"

	return fmt.Sprintf(`// Code generated by the Compiler. DO NOT EDIT.
//go:build js && wasm

package %s

import (
    "syscall/js"
    "fmt"
    "%s"
)

var _ = fmt.Sprint

func (c *Component) Render() js.Value {
    doc := js.Global().Get("document")
    %s
    return root
}
`, packageName, signalImport, body)
}

func Parse(r io.Reader) (*Node, error) {
	b, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}

	s := string(b)
	s = eventRegex.ReplaceAllString(s, "data-event-$1=")
	s = gIfRegex.ReplaceAllString(s, "data-g-if=")

	decoder := xml.NewDecoder(strings.NewReader(s))
	var root Node
	if err := decoder.Decode(&root); err != nil {
		return nil, err
	}

	return &root, nil
}

func generateNodeCode(n Node, varName string, parentVarName string, id int) string {
	var builder strings.Builder

	// 1. Handle *gIf Structural Directive
	for i, attr := range n.Attrs {
		if attr.Name.Local == "data-g-if" {
			return generateIfAttributes(attr, n, i, id, parentVarName)
		}
	}

	// 2. Normal Element Creation
	tag := n.XMLName.Local
	builder.WriteString(fmt.Sprintf(`%s := doc.Call("createElement", "%s")`+"\n", varName, tag))

	// Append to parent immediately (if not root/detached)
	if parentVarName != "" {
		builder.WriteString(fmt.Sprintf(`%s.Call("appendChild", %s)`+"\n", parentVarName, varName))
	}

	generateAttributesCode(n, varName, &builder)
	generateContentAndInterpolation(n, id, varName, &builder)
	generateRecursionFunction(n, varName, id, &builder)

	return builder.String()
}

func generateIfAttributes(attr xml.Attr, n Node, i int, id int, parentVarName string) string {
	condition := attr.Value

	// Remove *gIf for the inner element generation
	nodeCopy := n
	nodeCopy.Attrs = append(n.Attrs[:i], n.Attrs[i+1:]...)

	// Generate the inner element code
	// Pass "" as parent because we manually handle insertion inside the effect
	innerCode := generateNodeCode(nodeCopy, "innerEl", "", id)

	return fmt.Sprintf(`
            // --- *gIf (%s) ---
            anchor%d := doc.Call("createComment", "gIf-anchor")
            %s.Call("appendChild", anchor%d) // Append Anchor to Parent
            var mountedEl%d js.Value
            
            signal.CreateEffect(func() {
                shouldShow := c.%s // Auto-prepend 'c.'

                if shouldShow {
                    if !mountedEl%d.Truthy() {
                         // Create the element (detached)
                         %s 
                         mountedEl%d = innerEl
                         // Insert Real Element after Anchor
                         %s.Call("insertBefore", mountedEl%d, anchor%d.Get("nextSibling"))
                    }
                } else {
                    if mountedEl%d.Truthy() {
                        mountedEl%d.Call("remove")
                        mountedEl%d = js.Undefined()
                    }
                }
            })
            `, condition, id, parentVarName, id, id, condition, id, innerCode, id, parentVarName, id, id, id, id, id)
}

func generateRecursionFunction(n Node, varName string, id int, builder *strings.Builder) {
	for i, child := range n.Children {
		childVarName := fmt.Sprintf("%s_%d", varName, i)

		childCode := generateNodeCode(child, childVarName, varName, id+i+1)
		builder.WriteString("{\n")
		builder.WriteString(childCode)
		builder.WriteString("}\n")
	}
}

func generateContentAndInterpolation(n Node, id int, varName string, builder *strings.Builder) {
	if len(strings.TrimSpace(n.Content)) > 0 {
		content := strings.TrimSpace(n.Content)
		if strings.Contains(content, "{{") {
			parts := strings.Split(content, "{{")
			expr := strings.Split(parts[1], "}}")[0]
			expr = strings.TrimSpace(expr)

			code := fmt.Sprintf(`
            text%d := doc.Call("createTextNode", "")
            %s.Call("appendChild", text%d)
            signal.CreateEffect(func() {
                text%d.Set("nodeValue", fmt.Sprintf("%%v", c.%s))
            })`, id, varName, id, id, expr)
			builder.WriteString(code + "\n")
		} else {
			builder.WriteString(fmt.Sprintf(`%s.Set("innerText", "%s")`+"\n", varName, content))
		}
	}
}

func generateAttributesCode(n Node, varName string, builder *strings.Builder) {
	for _, attr := range n.Attrs {
		name := attr.Name.Local
		val := attr.Value

		if strings.HasPrefix(name, "data-event-") {
			eventName := strings.TrimPrefix(name, "data-event-")
			methodName := strings.TrimSuffix(val, "()")

			code := fmt.Sprintf(`
            %s.Call("addEventListener", "%s", js.FuncOf(func(this js.Value, args []js.Value) any {
                c.%s()
                return nil
            }))`, varName, eventName, methodName)
			builder.WriteString(code + "\n")
		} else {
			builder.WriteString(fmt.Sprintf(`%s.Call("setAttribute", "%s", "%s")`+"\n", varName, name, val))
		}
	}
}
