package compiler

import (
	"encoding/xml"
	"fmt"
	"io"
	"regexp"
	"strings"
	"unicode"
)

type Node struct {
	XMLName  xml.Name
	Attrs    []xml.Attr `xml:",any,attr"`
	Content  string     `xml:",chardata"`
	Children []Node     `xml:",any"`
}

var eventRegex = regexp.MustCompile(`\(([\w-]+)\)=`)
var gIfRegex = regexp.MustCompile(`\*gIf=`)
var gForRegex = regexp.MustCompile(`\*gFor=`)
var cssSelectorRegex = regexp.MustCompile(`([^{}]+)\{`)

func GenerateFullFile(n Node, packageName string, cssContent string, knownComponents map[string]bool, validFields map[string]bool) string {
	scopeId := fmt.Sprintf("data-c-%s", packageName)
	scopedCSS := cssSelectorRegex.ReplaceAllStringFunc(cssContent, func(match string) string {
		selectorPart := strings.TrimSuffix(match, "{")
		selectors := strings.Split(selectorPart, ",")

		var scopedList []string
		for _, s := range selectors {
			s = strings.TrimSpace(s)
			if s == "" {
				continue
			}
			scopedList = append(scopedList, fmt.Sprintf("%s[%s]", s, scopeId))
		}

		return strings.Join(scopedList, ", ") + " {"
	})

	scopedCSS = strings.ReplaceAll(scopedCSS, "\n", " ")
	scopedCSS = strings.ReplaceAll(scopedCSS, "\"", "'")
	body := generateNodeCode(n, "root", "", 0, scopeId, knownComponents, validFields)

	signalImport := "go-frontend-framework/signal"
	componentImport := "go-frontend-framework/component"

	return fmt.Sprintf(`// Code generated by the Compiler. DO NOT EDIT.
//go:build js && wasm

package %s

import (
    "syscall/js"
    "fmt"
    "%s"
    "%s"
)

// SUPPRESSORS: Prevent "imported and not used" errors
var _ = fmt.Sprint
var _ = signal.New[int]  // Forces usage of 'signal'
var _ = component.Create // Forces usage of 'component'

func init() {
    doc := js.Global().Get("document")
    head := doc.Get("head")
    style := doc.Call("createElement", "style")
    style.Set("innerHTML", %q)
    head.Call("appendChild", style)
}

func (c *Component) Render() js.Value {
    doc := js.Global().Get("document")
    %s
    return root
}
`, packageName, signalImport, componentImport, scopedCSS, body)
}

func Parse(r io.Reader) (*Node, error) {
	b, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}

	s := string(b)
	s = eventRegex.ReplaceAllString(s, "data-event-$1=")
	s = gIfRegex.ReplaceAllString(s, "data-g-if=")
	s = gForRegex.ReplaceAllString(s, "data-g-for=")

	decoder := xml.NewDecoder(strings.NewReader(s))
	var root Node
	if err := decoder.Decode(&root); err != nil {
		return nil, err
	}

	return &root, nil
}

func generateNodeCode(n Node, varName string, parentVarName string, id int, scopeId string, knownComponents map[string]bool, validFields map[string]bool) string {
	var builder strings.Builder

	for i, attr := range n.Attrs {
		if attr.Name.Local == "data-g-if" {
			return generateIfAttributes(attr, n, i, id, parentVarName, scopeId, knownComponents, validFields)
		}

		if attr.Name.Local == "data-g-for" {
			return generateForAttribute(attr, n, i, id, parentVarName, scopeId, knownComponents, validFields)
		}
	}

	tag := n.XMLName.Local

	isComponent := knownComponents[tag]

	if isComponent {
		builder.WriteString(fmt.Sprintf(`
        // --- Child Component: <%s> ---
        var %s js.Value
        {
            // 1. Create Instance
            childComp := component.Create("%s")
            
            // 2. Handle Inputs (Attributes starting with [ ])
            `, tag, varName, tag))
		for _, attr := range n.Attrs {
			name := attr.Name.Local
			value := attr.Value

			if strings.HasPrefix(name, "bind-") {
				inputName := name[5:]
				// USE SMART SCOPE
				scopedValue := smartScope(value, validFields)

				builder.WriteString(fmt.Sprintf(`
					signal.CreateEffect(func() {
						childComp.SetInput("%s", %s)
					})`,
					inputName, scopedValue))
			}

			if strings.HasPrefix(name, "on-") {
				eventName := name[3:]
				paramCall := value
				if strings.Contains(value, "$event") {
					paramCall = strings.Replace(value, "$event", "payload", 1)
				}

				builder.WriteString(fmt.Sprintf(`
                childComp.SetEventListener("%s", func(payload any) {
                    c.%s 
                })`, eventName, paramCall))
			}
		}

		builder.WriteString(fmt.Sprintf(`
            // 3. Render
            %s = childComp.Render()
        }
        `, varName))
	} else {
		builder.WriteString(fmt.Sprintf(`%s := doc.Call("createElement", "%s")`+"\n", varName, tag))
		builder.WriteString(fmt.Sprintf(`%s.Call("setAttribute", "%s", "")`+"\n", varName, scopeId))
		generateAttributesCode(n, varName, &builder)
	}

	if parentVarName != "" {
		builder.WriteString(fmt.Sprintf(`%s.Call("appendChild", %s)`+"\n", parentVarName, varName))
	}

	if !isComponent {
		generateContentAndInterpolation(n, id, varName, &builder, validFields)
		generateRecursionFunction(n, varName, id, &builder, scopeId, knownComponents, validFields)
	}

	return builder.String()
}

func generateIfAttributes(attr xml.Attr, n Node, i int, id int, parentVarName string, scopeId string, knownComponents map[string]bool, validFields map[string]bool) string {
	condition := attr.Value
	nodeCopy := n
	nodeCopy.Attrs = append(n.Attrs[:i], n.Attrs[i+1:]...)
	innerCode := generateNodeCode(nodeCopy, "innerEl", "", id, scopeId, knownComponents, validFields)

	return fmt.Sprintf(`
            // --- *gIf (%s) ---
            anchor%d := doc.Call("createComment", "gIf-anchor")
            %s.Call("appendChild", anchor%d) // Append Anchor to Parent
            var mountedEl%d js.Value
            
            signal.CreateEffect(func() {
                shouldShow := c.%s // Auto-prepend 'c.'

                if shouldShow {
                    if !mountedEl%d.Truthy() {
                         // Create the element (detached)
                         %s 
                         mountedEl%d = innerEl
                         // Insert Real Element after Anchor
                         %s.Call("insertBefore", mountedEl%d, anchor%d.Get("nextSibling"))
                    }
                } else {
                    if mountedEl%d.Truthy() {
                        mountedEl%d.Call("remove")
                        mountedEl%d = js.Undefined()
                    }
                }
            })
            `, condition, id, parentVarName, id, id, condition, id, innerCode, id, parentVarName, id, id, id, id, id)
}

func generateForAttribute(attr xml.Attr, n Node, i int, id int, parentVarName string, scopeId string, knownComponents map[string]bool, validFields map[string]bool) string {
	parts := strings.Split(attr.Value, " of ")
	itemName := parts[0]
	listName := parts[1]

	nodeCopy := n
	nodeCopy.Attrs = append(n.Attrs[:i], n.Attrs[i+1:]...)
	innerCode := generateNodeCode(nodeCopy, "iterEl", "", id, scopeId, knownComponents, validFields)

	return fmt.Sprintf(`
            // --- *gFor (%s of %s) ---
            anchor%d := doc.Call("createComment", "gFor-anchor")
            %s.Call("appendChild", anchor%d)
            var mountedItems%d []js.Value

            signal.CreateEffect(func() {
                // Cleanup
                for _, el := range mountedItems%d {
                    el.Call("remove")
                }
                mountedItems%d = nil

                // Render
                list := c.%s.Get()
                for _, %s := range list {
                    {
                        %s
                        mountedItems%d = append(mountedItems%d, iterEl)
                        %s.Call("insertBefore", iterEl, anchor%d.Get("nextSibling"))
                    }
                }
            })`,
		itemName, listName,
		id, parentVarName, id, id,
		id, id,
		listName, itemName,
		innerCode,
		id, id, parentVarName, id)
}

func generateRecursionFunction(n Node, varName string, id int, builder *strings.Builder, scopeId string, knownComponents map[string]bool, validFields map[string]bool) {
	for i, child := range n.Children {
		childVarName := fmt.Sprintf("%s_%d", varName, i)

		childCode := generateNodeCode(child, childVarName, varName, id+i+1, scopeId, knownComponents, validFields)
		builder.WriteString("{\n")
		builder.WriteString(childCode)
		builder.WriteString("}\n")
	}
}

func generateContentAndInterpolation(n Node, id int, varName string, builder *strings.Builder, validFields map[string]bool) {
	if len(strings.TrimSpace(n.Content)) > 0 {
		content := strings.TrimSpace(n.Content)

		if strings.Contains(content, "{{") {
			parts := strings.Split(content, "{{")
			prefix := parts[0]

			rest := parts[1]
			endParts := strings.Split(rest, "}}")
			expr := strings.TrimSpace(endParts[0])
			suffix := ""
			if len(endParts) > 1 {
				suffix = endParts[1]
			}

			if len(prefix) > 0 {
				builder.WriteString(fmt.Sprintf(`
                txtPrefix%d := doc.Call("createTextNode", %q)
                %s.Call("appendChild", txtPrefix%d)
                `, id, prefix, varName, id))
			}

			scopedExpr := smartScope(expr, validFields)

			builder.WriteString(fmt.Sprintf(`
            txtDyn%d := doc.Call("createTextNode", "")
            %s.Call("appendChild", txtDyn%d)
            signal.CreateEffect(func() {
                txtDyn%d.Set("nodeValue", fmt.Sprintf("%%v", %s))
            })`, id, varName, id, id, scopedExpr))

			if len(suffix) > 0 {
				builder.WriteString(fmt.Sprintf(`
                txtSuffix%d := doc.Call("createTextNode", %q)
                %s.Call("appendChild", txtSuffix%d)
                `, id, suffix, varName, id))
			}

		} else {
			builder.WriteString(fmt.Sprintf(`%s.Set("innerText", %q)`+"\n", varName, content))
		}
	}
}

func generateAttributesCode(n Node, varName string, builder *strings.Builder) {
	for _, attr := range n.Attrs {
		name := attr.Name.Local
		val := attr.Value

		if strings.HasPrefix(name, "data-event-") {
			eventName := strings.TrimPrefix(name, "data-event-")
			methodName := strings.TrimSuffix(val, "()")

			code := fmt.Sprintf(`
            %s.Call("addEventListener", "%s", js.FuncOf(func(this js.Value, args []js.Value) any {
                c.%s()
                return nil
            }))`, varName, eventName, methodName)
			builder.WriteString(code + "\n")
		} else {
			builder.WriteString(fmt.Sprintf(`%s.Call("setAttribute", "%s", "%s")`+"\n", varName, name, val))
		}
	}
}

func smartScope(expression string, validFields map[string]bool) string {
	expression = strings.TrimSpace(expression)
	if expression == "" {
		return ""
	}

	end := 0

	for i, r := range expression {
		if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '_' {
			break
		}

		end = i + 1
	}

	firstToken := expression[:end]

	if validFields[firstToken] {
		return "c." + expression
	}

	return expression
}
