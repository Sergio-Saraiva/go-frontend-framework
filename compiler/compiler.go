package compiler

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

type FoundComponent struct {
	Name       string
	ImportPath string
	TagName    string
	HtmlPath   string
	Fields     map[string]bool
}

func Run() error {
	rootDir := "src/app"
	fmt.Println("Starting Smart Auto-Discovery...")

	knownComponentsMap := make(map[string]bool)
	var foundComps []FoundComponent

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(info.Name(), ".html") {
			comp := analyzeComponent(path)
			if comp != nil {
				foundComps = append(foundComps, *comp)
				knownComponentsMap[comp.TagName] = true
			}
		}
		return nil
	})
	if err != nil {
		panic(err)
	}

	for _, comp := range foundComps {
		compileComponent(comp, knownComponentsMap)
	}

	generateRegistryFile(foundComps)
	generateBootstrapFile()

	fmt.Println("Discovery & Compilation Complete.")
	return nil
}

func analyzeComponent(htmlPath string) *FoundComponent {
	dir := filepath.Dir(htmlPath)
	name := filepath.Base(dir)
	goPath := filepath.Join(dir, name+".go")

	if _, err := os.Stat(goPath); os.IsNotExist(err) {
		return nil
	}

	isComponent, customSelector, fields := parseComponentInfo(goPath)
	if !isComponent {
		return nil
	}

	tagName := name
	if customSelector != "" {
		tagName = customSelector
	}

	moduleName := getModuleName()
	importPath := moduleName + "/src/app/" + name

	return &FoundComponent{
		Name:       name,
		ImportPath: importPath,
		TagName:    tagName,
		HtmlPath:   htmlPath,
		Fields:     fields,
	}
}

func compileComponent(comp FoundComponent, knownComponents map[string]bool) {
	cssPath := strings.Replace(comp.HtmlPath, ".html", ".css", 1)
	htmlContent, _ := os.ReadFile(comp.HtmlPath)

	cssContent := ""
	cssBytes, _ := os.ReadFile(cssPath)
	if cssBytes != nil {
		cssContent = string(cssBytes)
	}

	root, err := Parse(strings.NewReader(string(htmlContent)))
	if err != nil {
		fmt.Printf("Error parsing %s: %v\n", comp.HtmlPath, err)
		return
	}

	code := GenerateFullFile(*root, comp.Name, cssContent, knownComponents, comp.Fields)

	outputPath := filepath.Join(filepath.Dir(comp.HtmlPath), comp.Name+"_gen.go")
	os.WriteFile(outputPath, []byte(code), 0644)

	fmt.Printf("Compiling: %s -> <%s>\n", comp.Name, comp.TagName)
}

func generateRegistryFile(comps []FoundComponent) {
	var imports strings.Builder
	var registrations strings.Builder

	for _, c := range comps {
		alias := c.Name + "_pkg"
		imports.WriteString(fmt.Sprintf("\t%s \"%s\"\n", alias, c.ImportPath))
		registrations.WriteString(fmt.Sprintf("\tcomponent.Register(\"%s\", func() component.Interface { return %s.New() })\n", c.TagName, alias))
	}

	content := fmt.Sprintf(`// Code generated by the Compiler. DO NOT EDIT.
//go:build js && wasm

package app

import (
	"github.com/Sergio-Saraiva/go-frontend-framework/component"
%s
)

func init() {
%s
}
`, imports.String(), registrations.String())

	os.WriteFile("src/app/registry_gen.go", []byte(content), 0644)
	fmt.Println("Generated Registry: src/app/registry_gen.go")
}

func parseComponentInfo(filePath string) (bool, string, map[string]bool) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return false, "", nil
	}

	hasComponent := false
	selector := ""
	fields := make(map[string]bool)

	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if typeSpec.Name.Name == "Component" {
				hasComponent = true
				if structType, ok := typeSpec.Type.(*ast.StructType); ok {
					for _, field := range structType.Fields.List {
						for _, name := range field.Names {
							fields[name.Name] = true
						}
					}
				}
			}
		}

		if funcDecl, ok := n.(*ast.FuncDecl); ok {
			if funcDecl.Recv != nil {
				for _, field := range funcDecl.Recv.List {
					if startExpr, ok := field.Type.(*ast.StarExpr); ok {
						if ident, ok := startExpr.X.(*ast.Ident); ok && ident.Name == "Component" {
							fields[funcDecl.Name.Name] = true
						}
					}
				}
			}
		}

		if genDecl, ok := n.(*ast.GenDecl); ok && genDecl.Tok == token.CONST {
			for _, spec := range genDecl.Specs {
				valSpec := spec.(*ast.ValueSpec)
				if len(valSpec.Names) > 0 && valSpec.Names[0].Name == "Selector" {
					if len(valSpec.Values) > 0 {
						if basicLit, ok := valSpec.Values[0].(*ast.BasicLit); ok {
							selector = strings.Trim(basicLit.Value, "\"")
						}
					}
				}
			}
		}

		return true
	})

	return hasComponent, selector, fields
}

func generateBootstrapFile() {
	moduleName := getModuleName()
	registryCode := fmt.Sprintf(`// Code generated by Compiler. DO NOT EDIT.
package app

import (
	"github.com/Sergio-Saraiva/go-frontend-framework/component"
	app_components "%s/src/app" 
)
`, moduleName)

	err := os.WriteFile("bootstrap_gen.go", []byte(registryCode), 0644)
	if err != nil {
		fmt.Printf("Could not generate bootstrap file: %v\n", err)
	} else {
		fmt.Println("Generated Bootstrap: bootstrap_gen.go")
	}
}

func getModuleName() string {
	data, err := os.ReadFile("go.mod")
	if err != nil {
		return "app" // Fallback
	}

	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module "))
		}
	}
	return "app"
}
